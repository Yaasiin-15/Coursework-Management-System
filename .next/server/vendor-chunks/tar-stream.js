/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar-stream";
exports.ids = ["vendor-chunks/tar-stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/tar-stream/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/tar-stream/constants.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const constants = { // just for envs without fs\n  S_IFMT: 61440,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960\n}\n\ntry {\n  module.exports = (__webpack_require__(/*! fs */ \"fs\").constants) || constants\n} catch {\n  module.exports = constants\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLCtDQUF1QjtBQUMxQyxFQUFFO0FBQ0Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvdXJzZXdvcmstbWFuYWdlbWVudC8uL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2NvbnN0YW50cy5qcz9mNmYyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnN0YW50cyA9IHsgLy8ganVzdCBmb3IgZW52cyB3aXRob3V0IGZzXG4gIFNfSUZNVDogNjE0NDAsXG4gIFNfSUZESVI6IDE2Mzg0LFxuICBTX0lGQ0hSOiA4MTkyLFxuICBTX0lGQkxLOiAyNDU3NixcbiAgU19JRklGTzogNDA5NixcbiAgU19JRkxOSzogNDA5NjBcbn1cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdmcycpLmNvbnN0YW50cyB8fCBjb25zdGFudHNcbn0gY2F0Y2gge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50c1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/extract.js":
/*!********************************************!*\
  !*** ./node_modules/tar-stream/extract.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Writable, Readable, getStreamError } = __webpack_require__(/*! streamx */ \"(rsc)/./node_modules/streamx/index.js\")\nconst FIFO = __webpack_require__(/*! fast-fifo */ \"(rsc)/./node_modules/fast-fifo/index.js\")\nconst b4a = __webpack_require__(/*! b4a */ \"(rsc)/./node_modules/b4a/index.js\")\nconst headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/tar-stream/headers.js\")\n\nconst EMPTY = b4a.alloc(0)\n\nclass BufferList {\n  constructor () {\n    this.buffered = 0\n    this.shifted = 0\n    this.queue = new FIFO()\n\n    this._offset = 0\n  }\n\n  push (buffer) {\n    this.buffered += buffer.byteLength\n    this.queue.push(buffer)\n  }\n\n  shiftFirst (size) {\n    return this._buffered === 0 ? null : this._next(size)\n  }\n\n  shift (size) {\n    if (size > this.buffered) return null\n    if (size === 0) return EMPTY\n\n    let chunk = this._next(size)\n\n    if (size === chunk.byteLength) return chunk // likely case\n\n    const chunks = [chunk]\n\n    while ((size -= chunk.byteLength) > 0) {\n      chunk = this._next(size)\n      chunks.push(chunk)\n    }\n\n    return b4a.concat(chunks)\n  }\n\n  _next (size) {\n    const buf = this.queue.peek()\n    const rem = buf.byteLength - this._offset\n\n    if (size >= rem) {\n      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf\n      this.queue.shift()\n      this._offset = 0\n      this.buffered -= rem\n      this.shifted += rem\n      return sub\n    }\n\n    this.buffered -= size\n    this.shifted += size\n\n    return buf.subarray(this._offset, (this._offset += size))\n  }\n}\n\nclass Source extends Readable {\n  constructor (self, header, offset) {\n    super()\n\n    this.header = header\n    this.offset = offset\n\n    this._parent = self\n  }\n\n  _read (cb) {\n    if (this.header.size === 0) {\n      this.push(null)\n    }\n    if (this._parent._stream === this) {\n      this._parent._update()\n    }\n    cb(null)\n  }\n\n  _predestroy () {\n    this._parent.destroy(getStreamError(this))\n  }\n\n  _detach () {\n    if (this._parent._stream === this) {\n      this._parent._stream = null\n      this._parent._missing = overflow(this.header.size)\n      this._parent._update()\n    }\n  }\n\n  _destroy (cb) {\n    this._detach()\n    cb(null)\n  }\n}\n\nclass Extract extends Writable {\n  constructor (opts) {\n    super(opts)\n\n    if (!opts) opts = {}\n\n    this._buffer = new BufferList()\n    this._offset = 0\n    this._header = null\n    this._stream = null\n    this._missing = 0\n    this._longHeader = false\n    this._callback = noop\n    this._locked = false\n    this._finished = false\n    this._pax = null\n    this._paxGlobal = null\n    this._gnuLongPath = null\n    this._gnuLongLinkPath = null\n    this._filenameEncoding = opts.filenameEncoding || 'utf-8'\n    this._allowUnknownFormat = !!opts.allowUnknownFormat\n    this._unlockBound = this._unlock.bind(this)\n  }\n\n  _unlock (err) {\n    this._locked = false\n\n    if (err) {\n      this.destroy(err)\n      this._continueWrite(err)\n      return\n    }\n\n    this._update()\n  }\n\n  _consumeHeader () {\n    if (this._locked) return false\n\n    this._offset = this._buffer.shifted\n\n    try {\n      this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    if (!this._header) return true\n\n    switch (this._header.type) {\n      case 'gnu-long-path':\n      case 'gnu-long-link-path':\n      case 'pax-global-header':\n      case 'pax-header':\n        this._longHeader = true\n        this._missing = this._header.size\n        return true\n    }\n\n    this._locked = true\n    this._applyLongHeaders()\n\n    if (this._header.size === 0 || this._header.type === 'directory') {\n      this.emit('entry', this._header, this._createStream(), this._unlockBound)\n      return true\n    }\n\n    this._stream = this._createStream()\n    this._missing = this._header.size\n\n    this.emit('entry', this._header, this._stream, this._unlockBound)\n    return true\n  }\n\n  _applyLongHeaders () {\n    if (this._gnuLongPath) {\n      this._header.name = this._gnuLongPath\n      this._gnuLongPath = null\n    }\n\n    if (this._gnuLongLinkPath) {\n      this._header.linkname = this._gnuLongLinkPath\n      this._gnuLongLinkPath = null\n    }\n\n    if (this._pax) {\n      if (this._pax.path) this._header.name = this._pax.path\n      if (this._pax.linkpath) this._header.linkname = this._pax.linkpath\n      if (this._pax.size) this._header.size = parseInt(this._pax.size, 10)\n      this._header.pax = this._pax\n      this._pax = null\n    }\n  }\n\n  _decodeLongHeader (buf) {\n    switch (this._header.type) {\n      case 'gnu-long-path':\n        this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'gnu-long-link-path':\n        this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'pax-global-header':\n        this._paxGlobal = headers.decodePax(buf)\n        break\n      case 'pax-header':\n        this._pax = this._paxGlobal === null\n          ? headers.decodePax(buf)\n          : Object.assign({}, this._paxGlobal, headers.decodePax(buf))\n        break\n    }\n  }\n\n  _consumeLongHeader () {\n    this._longHeader = false\n    this._missing = overflow(this._header.size)\n\n    const buf = this._buffer.shift(this._header.size)\n\n    try {\n      this._decodeLongHeader(buf)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    return true\n  }\n\n  _consumeStream () {\n    const buf = this._buffer.shiftFirst(this._missing)\n    if (buf === null) return false\n\n    this._missing -= buf.byteLength\n    const drained = this._stream.push(buf)\n\n    if (this._missing === 0) {\n      this._stream.push(null)\n      if (drained) this._stream._detach()\n      return drained && this._locked === false\n    }\n\n    return drained\n  }\n\n  _createStream () {\n    return new Source(this, this._header, this._offset)\n  }\n\n  _update () {\n    while (this._buffer.buffered > 0 && !this.destroying) {\n      if (this._missing > 0) {\n        if (this._stream !== null) {\n          if (this._consumeStream() === false) return\n          continue\n        }\n\n        if (this._longHeader === true) {\n          if (this._missing > this._buffer.buffered) break\n          if (this._consumeLongHeader() === false) return false\n          continue\n        }\n\n        const ignore = this._buffer.shiftFirst(this._missing)\n        if (ignore !== null) this._missing -= ignore.byteLength\n        continue\n      }\n\n      if (this._buffer.buffered < 512) break\n      if (this._stream !== null || this._consumeHeader() === false) return\n    }\n\n    this._continueWrite(null)\n  }\n\n  _continueWrite (err) {\n    const cb = this._callback\n    this._callback = noop\n    cb(err)\n  }\n\n  _write (data, cb) {\n    this._callback = cb\n    this._buffer.push(data)\n    this._update()\n  }\n\n  _final (cb) {\n    this._finished = this._missing === 0 && this._buffer.buffered === 0\n    cb(this._finished ? null : new Error('Unexpected end of data'))\n  }\n\n  _predestroy () {\n    this._continueWrite(null)\n  }\n\n  _destroy (cb) {\n    if (this._stream) this._stream.destroy(getStreamError(this))\n    cb(null)\n  }\n\n  [Symbol.asyncIterator] () {\n    let error = null\n\n    let promiseResolve = null\n    let promiseReject = null\n\n    let entryStream = null\n    let entryCallback = null\n\n    const extract = this\n\n    this.on('entry', onentry)\n    this.on('error', (err) => { error = err })\n    this.on('close', onclose)\n\n    return {\n      [Symbol.asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(onnext)\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function consumeCallback (err) {\n      if (!entryCallback) return\n      const cb = entryCallback\n      entryCallback = null\n      cb(err)\n    }\n\n    function onnext (resolve, reject) {\n      if (error) {\n        return reject(error)\n      }\n\n      if (entryStream) {\n        resolve({ value: entryStream, done: false })\n        entryStream = null\n        return\n      }\n\n      promiseResolve = resolve\n      promiseReject = reject\n\n      consumeCallback(null)\n\n      if (extract._finished && promiseResolve) {\n        promiseResolve({ value: undefined, done: true })\n        promiseResolve = promiseReject = null\n      }\n    }\n\n    function onentry (header, stream, callback) {\n      entryCallback = callback\n      stream.on('error', noop) // no way around this due to tick sillyness\n\n      if (promiseResolve) {\n        promiseResolve({ value: stream, done: false })\n        promiseResolve = promiseReject = null\n      } else {\n        entryStream = stream\n      }\n    }\n\n    function onclose () {\n      consumeCallback(error)\n      if (!promiseResolve) return\n      if (error) promiseReject(error)\n      else promiseResolve({ value: undefined, done: true })\n      promiseResolve = promiseReject = null\n    }\n\n    function destroy (err) {\n      extract.destroy(err)\n      consumeCallback(err)\n      return new Promise((resolve, reject) => {\n        if (extract.destroyed) return resolve({ value: undefined, done: true })\n        extract.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nmodule.exports = function extract (opts) {\n  return new Extract(opts)\n}\n\nfunction noop () {}\n\nfunction overflow (size) {\n  size &= 511\n  return size && 512 - size\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyxzREFBUztBQUNoRSxhQUFhLG1CQUFPLENBQUMsMERBQVc7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLDhDQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvdXJzZXdvcmstbWFuYWdlbWVudC8uL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2V4dHJhY3QuanM/ODI5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IFdyaXRhYmxlLCBSZWFkYWJsZSwgZ2V0U3RyZWFtRXJyb3IgfSA9IHJlcXVpcmUoJ3N0cmVhbXgnKVxuY29uc3QgRklGTyA9IHJlcXVpcmUoJ2Zhc3QtZmlmbycpXG5jb25zdCBiNGEgPSByZXF1aXJlKCdiNGEnKVxuY29uc3QgaGVhZGVycyA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5cbmNvbnN0IEVNUFRZID0gYjRhLmFsbG9jKDApXG5cbmNsYXNzIEJ1ZmZlckxpc3Qge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLnNoaWZ0ZWQgPSAwXG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBGSUZPKClcblxuICAgIHRoaXMuX29mZnNldCA9IDBcbiAgfVxuXG4gIHB1c2ggKGJ1ZmZlcikge1xuICAgIHRoaXMuYnVmZmVyZWQgKz0gYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICB0aGlzLnF1ZXVlLnB1c2goYnVmZmVyKVxuICB9XG5cbiAgc2hpZnRGaXJzdCAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9idWZmZXJlZCA9PT0gMCA/IG51bGwgOiB0aGlzLl9uZXh0KHNpemUpXG4gIH1cblxuICBzaGlmdCAoc2l6ZSkge1xuICAgIGlmIChzaXplID4gdGhpcy5idWZmZXJlZCkgcmV0dXJuIG51bGxcbiAgICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuIEVNUFRZXG5cbiAgICBsZXQgY2h1bmsgPSB0aGlzLl9uZXh0KHNpemUpXG5cbiAgICBpZiAoc2l6ZSA9PT0gY2h1bmsuYnl0ZUxlbmd0aCkgcmV0dXJuIGNodW5rIC8vIGxpa2VseSBjYXNlXG5cbiAgICBjb25zdCBjaHVua3MgPSBbY2h1bmtdXG5cbiAgICB3aGlsZSAoKHNpemUgLT0gY2h1bmsuYnl0ZUxlbmd0aCkgPiAwKSB7XG4gICAgICBjaHVuayA9IHRoaXMuX25leHQoc2l6ZSlcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgIH1cblxuICAgIHJldHVybiBiNGEuY29uY2F0KGNodW5rcylcbiAgfVxuXG4gIF9uZXh0IChzaXplKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy5xdWV1ZS5wZWVrKClcbiAgICBjb25zdCByZW0gPSBidWYuYnl0ZUxlbmd0aCAtIHRoaXMuX29mZnNldFxuXG4gICAgaWYgKHNpemUgPj0gcmVtKSB7XG4gICAgICBjb25zdCBzdWIgPSB0aGlzLl9vZmZzZXQgPyBidWYuc3ViYXJyYXkodGhpcy5fb2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCkgOiBidWZcbiAgICAgIHRoaXMucXVldWUuc2hpZnQoKVxuICAgICAgdGhpcy5fb2Zmc2V0ID0gMFxuICAgICAgdGhpcy5idWZmZXJlZCAtPSByZW1cbiAgICAgIHRoaXMuc2hpZnRlZCArPSByZW1cbiAgICAgIHJldHVybiBzdWJcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlcmVkIC09IHNpemVcbiAgICB0aGlzLnNoaWZ0ZWQgKz0gc2l6ZVxuXG4gICAgcmV0dXJuIGJ1Zi5zdWJhcnJheSh0aGlzLl9vZmZzZXQsICh0aGlzLl9vZmZzZXQgKz0gc2l6ZSkpXG4gIH1cbn1cblxuY2xhc3MgU291cmNlIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAoc2VsZiwgaGVhZGVyLCBvZmZzZXQpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLmhlYWRlciA9IGhlYWRlclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBzZWxmXG4gIH1cblxuICBfcmVhZCAoY2IpIHtcbiAgICBpZiAodGhpcy5oZWFkZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgfVxuICAgIGlmICh0aGlzLl9wYXJlbnQuX3N0cmVhbSA9PT0gdGhpcykge1xuICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGUoKVxuICAgIH1cbiAgICBjYihudWxsKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX3BhcmVudC5kZXN0cm95KGdldFN0cmVhbUVycm9yKHRoaXMpKVxuICB9XG5cbiAgX2RldGFjaCAoKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudC5fc3RyZWFtID09PSB0aGlzKSB7XG4gICAgICB0aGlzLl9wYXJlbnQuX3N0cmVhbSA9IG51bGxcbiAgICAgIHRoaXMuX3BhcmVudC5fbWlzc2luZyA9IG92ZXJmbG93KHRoaXMuaGVhZGVyLnNpemUpXG4gICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGNiKSB7XG4gICAgdGhpcy5fZGV0YWNoKClcbiAgICBjYihudWxsKVxuICB9XG59XG5cbmNsYXNzIEV4dHJhY3QgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpXG4gICAgdGhpcy5fb2Zmc2V0ID0gMFxuICAgIHRoaXMuX2hlYWRlciA9IG51bGxcbiAgICB0aGlzLl9zdHJlYW0gPSBudWxsXG4gICAgdGhpcy5fbWlzc2luZyA9IDBcbiAgICB0aGlzLl9sb25nSGVhZGVyID0gZmFsc2VcbiAgICB0aGlzLl9jYWxsYmFjayA9IG5vb3BcbiAgICB0aGlzLl9sb2NrZWQgPSBmYWxzZVxuICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2VcbiAgICB0aGlzLl9wYXggPSBudWxsXG4gICAgdGhpcy5fcGF4R2xvYmFsID0gbnVsbFxuICAgIHRoaXMuX2dudUxvbmdQYXRoID0gbnVsbFxuICAgIHRoaXMuX2dudUxvbmdMaW5rUGF0aCA9IG51bGxcbiAgICB0aGlzLl9maWxlbmFtZUVuY29kaW5nID0gb3B0cy5maWxlbmFtZUVuY29kaW5nIHx8ICd1dGYtOCdcbiAgICB0aGlzLl9hbGxvd1Vua25vd25Gb3JtYXQgPSAhIW9wdHMuYWxsb3dVbmtub3duRm9ybWF0XG4gICAgdGhpcy5fdW5sb2NrQm91bmQgPSB0aGlzLl91bmxvY2suYmluZCh0aGlzKVxuICB9XG5cbiAgX3VubG9jayAoZXJyKSB7XG4gICAgdGhpcy5fbG9ja2VkID0gZmFsc2VcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnIpXG4gICAgICB0aGlzLl9jb250aW51ZVdyaXRlKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gIH1cblxuICBfY29uc3VtZUhlYWRlciAoKSB7XG4gICAgaWYgKHRoaXMuX2xvY2tlZCkgcmV0dXJuIGZhbHNlXG5cbiAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9idWZmZXIuc2hpZnRlZFxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2hlYWRlciA9IGhlYWRlcnMuZGVjb2RlKHRoaXMuX2J1ZmZlci5zaGlmdCg1MTIpLCB0aGlzLl9maWxlbmFtZUVuY29kaW5nLCB0aGlzLl9hbGxvd1Vua25vd25Gb3JtYXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9jb250aW51ZVdyaXRlKGVycilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICghdGhpcy5faGVhZGVyKSByZXR1cm4gdHJ1ZVxuXG4gICAgc3dpdGNoICh0aGlzLl9oZWFkZXIudHlwZSkge1xuICAgICAgY2FzZSAnZ251LWxvbmctcGF0aCc6XG4gICAgICBjYXNlICdnbnUtbG9uZy1saW5rLXBhdGgnOlxuICAgICAgY2FzZSAncGF4LWdsb2JhbC1oZWFkZXInOlxuICAgICAgY2FzZSAncGF4LWhlYWRlcic6XG4gICAgICAgIHRoaXMuX2xvbmdIZWFkZXIgPSB0cnVlXG4gICAgICAgIHRoaXMuX21pc3NpbmcgPSB0aGlzLl9oZWFkZXIuc2l6ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuX2xvY2tlZCA9IHRydWVcbiAgICB0aGlzLl9hcHBseUxvbmdIZWFkZXJzKClcblxuICAgIGlmICh0aGlzLl9oZWFkZXIuc2l6ZSA9PT0gMCB8fCB0aGlzLl9oZWFkZXIudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgIHRoaXMuZW1pdCgnZW50cnknLCB0aGlzLl9oZWFkZXIsIHRoaXMuX2NyZWF0ZVN0cmVhbSgpLCB0aGlzLl91bmxvY2tCb3VuZClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5fc3RyZWFtID0gdGhpcy5fY3JlYXRlU3RyZWFtKClcbiAgICB0aGlzLl9taXNzaW5nID0gdGhpcy5faGVhZGVyLnNpemVcblxuICAgIHRoaXMuZW1pdCgnZW50cnknLCB0aGlzLl9oZWFkZXIsIHRoaXMuX3N0cmVhbSwgdGhpcy5fdW5sb2NrQm91bmQpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9hcHBseUxvbmdIZWFkZXJzICgpIHtcbiAgICBpZiAodGhpcy5fZ251TG9uZ1BhdGgpIHtcbiAgICAgIHRoaXMuX2hlYWRlci5uYW1lID0gdGhpcy5fZ251TG9uZ1BhdGhcbiAgICAgIHRoaXMuX2dudUxvbmdQYXRoID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9nbnVMb25nTGlua1BhdGgpIHtcbiAgICAgIHRoaXMuX2hlYWRlci5saW5rbmFtZSA9IHRoaXMuX2dudUxvbmdMaW5rUGF0aFxuICAgICAgdGhpcy5fZ251TG9uZ0xpbmtQYXRoID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXgpIHtcbiAgICAgIGlmICh0aGlzLl9wYXgucGF0aCkgdGhpcy5faGVhZGVyLm5hbWUgPSB0aGlzLl9wYXgucGF0aFxuICAgICAgaWYgKHRoaXMuX3BheC5saW5rcGF0aCkgdGhpcy5faGVhZGVyLmxpbmtuYW1lID0gdGhpcy5fcGF4LmxpbmtwYXRoXG4gICAgICBpZiAodGhpcy5fcGF4LnNpemUpIHRoaXMuX2hlYWRlci5zaXplID0gcGFyc2VJbnQodGhpcy5fcGF4LnNpemUsIDEwKVxuICAgICAgdGhpcy5faGVhZGVyLnBheCA9IHRoaXMuX3BheFxuICAgICAgdGhpcy5fcGF4ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVMb25nSGVhZGVyIChidWYpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX2hlYWRlci50eXBlKSB7XG4gICAgICBjYXNlICdnbnUtbG9uZy1wYXRoJzpcbiAgICAgICAgdGhpcy5fZ251TG9uZ1BhdGggPSBoZWFkZXJzLmRlY29kZUxvbmdQYXRoKGJ1ZiwgdGhpcy5fZmlsZW5hbWVFbmNvZGluZylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2dudS1sb25nLWxpbmstcGF0aCc6XG4gICAgICAgIHRoaXMuX2dudUxvbmdMaW5rUGF0aCA9IGhlYWRlcnMuZGVjb2RlTG9uZ1BhdGgoYnVmLCB0aGlzLl9maWxlbmFtZUVuY29kaW5nKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF4LWdsb2JhbC1oZWFkZXInOlxuICAgICAgICB0aGlzLl9wYXhHbG9iYWwgPSBoZWFkZXJzLmRlY29kZVBheChidWYpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXgtaGVhZGVyJzpcbiAgICAgICAgdGhpcy5fcGF4ID0gdGhpcy5fcGF4R2xvYmFsID09PSBudWxsXG4gICAgICAgICAgPyBoZWFkZXJzLmRlY29kZVBheChidWYpXG4gICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9wYXhHbG9iYWwsIGhlYWRlcnMuZGVjb2RlUGF4KGJ1ZikpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgX2NvbnN1bWVMb25nSGVhZGVyICgpIHtcbiAgICB0aGlzLl9sb25nSGVhZGVyID0gZmFsc2VcbiAgICB0aGlzLl9taXNzaW5nID0gb3ZlcmZsb3codGhpcy5faGVhZGVyLnNpemUpXG5cbiAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXIuc2hpZnQodGhpcy5faGVhZGVyLnNpemUpXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZGVjb2RlTG9uZ0hlYWRlcihidWYpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9jb250aW51ZVdyaXRlKGVycilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfY29uc3VtZVN0cmVhbSAoKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyLnNoaWZ0Rmlyc3QodGhpcy5fbWlzc2luZylcbiAgICBpZiAoYnVmID09PSBudWxsKSByZXR1cm4gZmFsc2VcblxuICAgIHRoaXMuX21pc3NpbmcgLT0gYnVmLmJ5dGVMZW5ndGhcbiAgICBjb25zdCBkcmFpbmVkID0gdGhpcy5fc3RyZWFtLnB1c2goYnVmKVxuXG4gICAgaWYgKHRoaXMuX21pc3NpbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5wdXNoKG51bGwpXG4gICAgICBpZiAoZHJhaW5lZCkgdGhpcy5fc3RyZWFtLl9kZXRhY2goKVxuICAgICAgcmV0dXJuIGRyYWluZWQgJiYgdGhpcy5fbG9ja2VkID09PSBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiBkcmFpbmVkXG4gIH1cblxuICBfY3JlYXRlU3RyZWFtICgpIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZSh0aGlzLCB0aGlzLl9oZWFkZXIsIHRoaXMuX29mZnNldClcbiAgfVxuXG4gIF91cGRhdGUgKCkge1xuICAgIHdoaWxlICh0aGlzLl9idWZmZXIuYnVmZmVyZWQgPiAwICYmICF0aGlzLmRlc3Ryb3lpbmcpIHtcbiAgICAgIGlmICh0aGlzLl9taXNzaW5nID4gMCkge1xuICAgICAgICBpZiAodGhpcy5fc3RyZWFtICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbnN1bWVTdHJlYW0oKSA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbG9uZ0hlYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9taXNzaW5nID4gdGhpcy5fYnVmZmVyLmJ1ZmZlcmVkKSBicmVha1xuICAgICAgICAgIGlmICh0aGlzLl9jb25zdW1lTG9uZ0hlYWRlcigpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IHRoaXMuX2J1ZmZlci5zaGlmdEZpcnN0KHRoaXMuX21pc3NpbmcpXG4gICAgICAgIGlmIChpZ25vcmUgIT09IG51bGwpIHRoaXMuX21pc3NpbmcgLT0gaWdub3JlLmJ5dGVMZW5ndGhcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2J1ZmZlci5idWZmZXJlZCA8IDUxMikgYnJlYWtcbiAgICAgIGlmICh0aGlzLl9zdHJlYW0gIT09IG51bGwgfHwgdGhpcy5fY29uc3VtZUhlYWRlcigpID09PSBmYWxzZSkgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY29udGludWVXcml0ZShudWxsKVxuICB9XG5cbiAgX2NvbnRpbnVlV3JpdGUgKGVycikge1xuICAgIGNvbnN0IGNiID0gdGhpcy5fY2FsbGJhY2tcbiAgICB0aGlzLl9jYWxsYmFjayA9IG5vb3BcbiAgICBjYihlcnIpXG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYlxuICAgIHRoaXMuX2J1ZmZlci5wdXNoKGRhdGEpXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICB0aGlzLl9maW5pc2hlZCA9IHRoaXMuX21pc3NpbmcgPT09IDAgJiYgdGhpcy5fYnVmZmVyLmJ1ZmZlcmVkID09PSAwXG4gICAgY2IodGhpcy5fZmluaXNoZWQgPyBudWxsIDogbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJykpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fY29udGludWVXcml0ZShudWxsKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0cmVhbSkgdGhpcy5fc3RyZWFtLmRlc3Ryb3koZ2V0U3RyZWFtRXJyb3IodGhpcykpXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgIGxldCBlcnJvciA9IG51bGxcblxuICAgIGxldCBwcm9taXNlUmVzb2x2ZSA9IG51bGxcbiAgICBsZXQgcHJvbWlzZVJlamVjdCA9IG51bGxcblxuICAgIGxldCBlbnRyeVN0cmVhbSA9IG51bGxcbiAgICBsZXQgZW50cnlDYWxsYmFjayA9IG51bGxcblxuICAgIGNvbnN0IGV4dHJhY3QgPSB0aGlzXG5cbiAgICB0aGlzLm9uKCdlbnRyeScsIG9uZW50cnkpXG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7IGVycm9yID0gZXJyIH0pXG4gICAgdGhpcy5vbignY2xvc2UnLCBvbmNsb3NlKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIG5leHQgKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2Uob25uZXh0KVxuICAgICAgfSxcbiAgICAgIHJldHVybiAoKSB7XG4gICAgICAgIHJldHVybiBkZXN0cm95KG51bGwpXG4gICAgICB9LFxuICAgICAgdGhyb3cgKGVycikge1xuICAgICAgICByZXR1cm4gZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZUNhbGxiYWNrIChlcnIpIHtcbiAgICAgIGlmICghZW50cnlDYWxsYmFjaykgcmV0dXJuXG4gICAgICBjb25zdCBjYiA9IGVudHJ5Q2FsbGJhY2tcbiAgICAgIGVudHJ5Q2FsbGJhY2sgPSBudWxsXG4gICAgICBjYihlcnIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25uZXh0IChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgfVxuXG4gICAgICBpZiAoZW50cnlTdHJlYW0pIHtcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBlbnRyeVN0cmVhbSwgZG9uZTogZmFsc2UgfSlcbiAgICAgICAgZW50cnlTdHJlYW0gPSBudWxsXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3RcblxuICAgICAgY29uc3VtZUNhbGxiYWNrKG51bGwpXG5cbiAgICAgIGlmIChleHRyYWN0Ll9maW5pc2hlZCAmJiBwcm9taXNlUmVzb2x2ZSkge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVqZWN0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uZW50cnkgKGhlYWRlciwgc3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgZW50cnlDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgbm9vcCkgLy8gbm8gd2F5IGFyb3VuZCB0aGlzIGR1ZSB0byB0aWNrIHNpbGx5bmVzc1xuXG4gICAgICBpZiAocHJvbWlzZVJlc29sdmUpIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUoeyB2YWx1ZTogc3RyZWFtLCBkb25lOiBmYWxzZSB9KVxuICAgICAgICBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZWplY3QgPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeVN0cmVhbSA9IHN0cmVhbVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgICAgY29uc3VtZUNhbGxiYWNrKGVycm9yKVxuICAgICAgaWYgKCFwcm9taXNlUmVzb2x2ZSkgcmV0dXJuXG4gICAgICBpZiAoZXJyb3IpIHByb21pc2VSZWplY3QoZXJyb3IpXG4gICAgICBlbHNlIHByb21pc2VSZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVqZWN0ID0gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3kgKGVycikge1xuICAgICAgZXh0cmFjdC5kZXN0cm95KGVycilcbiAgICAgIGNvbnN1bWVDYWxsYmFjayhlcnIpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoZXh0cmFjdC5kZXN0cm95ZWQpIHJldHVybiByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgICBleHRyYWN0Lm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpXG4gICAgICAgICAgZWxzZSByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRyYWN0IChvcHRzKSB7XG4gIHJldHVybiBuZXcgRXh0cmFjdChvcHRzKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIG92ZXJmbG93IChzaXplKSB7XG4gIHNpemUgJj0gNTExXG4gIHJldHVybiBzaXplICYmIDUxMiAtIHNpemVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/extract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/headers.js":
/*!********************************************!*\
  !*** ./node_modules/tar-stream/headers.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const b4a = __webpack_require__(/*! b4a */ \"(rsc)/./node_modules/b4a/index.js\")\n\nconst ZEROS = '0000000000000000000'\nconst SEVENS = '7777777777777777777'\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\\x00\nconst USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET])\nconst GNU_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\\x20\nconst GNU_VER = b4a.from([0x20, 0x00])\nconst MASK = 0o7777\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nexports.decodeLongPath = function decodeLongPath (buf, encoding) {\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.encodePax = function encodePax (opts) { // TODO: encode more stuff in pax\n  let result = ''\n  if (opts.name) result += addLength(' path=' + opts.name + '\\n')\n  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\\n')\n  const pax = opts.pax\n  if (pax) {\n    for (const key in pax) {\n      result += addLength(' ' + key + '=' + pax[key] + '\\n')\n    }\n  }\n  return b4a.from(result)\n}\n\nexports.decodePax = function decodePax (buf) {\n  const result = {}\n\n  while (buf.length) {\n    let i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n    const len = parseInt(b4a.toString(buf.subarray(0, i)), 10)\n    if (!len) return result\n\n    const b = b4a.toString(buf.subarray(i + 1, len - 1))\n    const keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.subarray(len)\n  }\n\n  return result\n}\n\nexports.encode = function encode (opts) {\n  const buf = b4a.alloc(512)\n  let name = opts.name\n  let prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'\n  if (b4a.byteLength(name) !== name.length) return null // utf-8\n\n  while (b4a.byteLength(name) > 100) {\n    const i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i + 1)\n  }\n\n  if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null\n  if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null\n\n  b4a.write(buf, name)\n  b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100)\n  b4a.write(buf, encodeOct(opts.uid, 6), 108)\n  b4a.write(buf, encodeOct(opts.gid, 6), 116)\n  encodeSize(opts.size, buf, 124)\n  b4a.write(buf, encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) b4a.write(buf, opts.linkname, 157)\n\n  b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET)\n  b4a.copy(USTAR_VER, buf, VERSION_OFFSET)\n  if (opts.uname) b4a.write(buf, opts.uname, 265)\n  if (opts.gname) b4a.write(buf, opts.gname, 297)\n  b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329)\n  b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) b4a.write(buf, prefix, 345)\n\n  b4a.write(buf, encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function decode (buf, filenameEncoding, allowUnknownFormat) {\n  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (isUSTAR(buf)) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (isGNU(buf)) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    if (!allowUnknownFormat) {\n      throw new Error('Invalid tar header: unknown format.')\n    }\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: new Date(1000 * mtime),\n    type,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor,\n    pax: null\n  }\n}\n\nfunction isUSTAR (buf) {\n  return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))\n}\n\nfunction isGNU (buf) {\n  return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&\n    b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))\n}\n\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction toType (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nfunction toTypeflag (flag) {\n  switch (flag) {\n    case 'file':\n      return 0\n    case 'link':\n      return 1\n    case 'symlink':\n      return 2\n    case 'character-device':\n      return 3\n    case 'block-device':\n      return 4\n    case 'directory':\n      return 5\n    case 'fifo':\n      return 6\n    case 'contiguous-file':\n      return 7\n    case 'pax-header':\n      return 72\n  }\n\n  return 0\n}\n\nfunction indexOf (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nfunction cksum (block) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block[i]\n  for (let j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\nfunction encodeOct (val, n) {\n  val = val.toString(8)\n  if (val.length > n) return SEVENS.slice(0, n) + ' '\n  return ZEROS.slice(0, n - val.length) + val + ' '\n}\n\nfunction encodeSizeBin (num, buf, off) {\n  buf[off] = 0x80\n  for (let i = 11; i > 0; i--) {\n    buf[off + i] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nfunction encodeSize (num, buf, off) {\n  if (num.toString(8).length > 11) {\n    encodeSizeBin(num, buf, off)\n  } else {\n    b4a.write(buf, encodeOct(num, 11), off)\n  }\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  const tuple = []\n  let i\n  for (i = buf.length - 1; i > 0; i--) {\n    const byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xFF - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nfunction decodeOct (val, offset, length) {\n  val = val.subarray(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val[offset] === 32) offset++\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val[offset] === 0) offset++\n    if (end === offset) return 0\n    return parseInt(b4a.toString(val.subarray(offset, end)), 8)\n  }\n}\n\nfunction decodeStr (val, offset, length, encoding) {\n  return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n\nfunction addLength (str) {\n  const len = b4a.byteLength(str)\n  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits >= Math.pow(10, digits)) digits++\n\n  return (len + digits) + str\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyw4Q0FBSzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY291cnNld29yay1tYW5hZ2VtZW50Ly4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vaGVhZGVycy5qcz9kNjRkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGI0YSA9IHJlcXVpcmUoJ2I0YScpXG5cbmNvbnN0IFpFUk9TID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAnXG5jb25zdCBTRVZFTlMgPSAnNzc3Nzc3Nzc3Nzc3Nzc3Nzc3NydcbmNvbnN0IFpFUk9fT0ZGU0VUID0gJzAnLmNoYXJDb2RlQXQoMClcbmNvbnN0IFVTVEFSX01BR0lDID0gYjRhLmZyb20oWzB4NzUsIDB4NzMsIDB4NzQsIDB4NjEsIDB4NzIsIDB4MDBdKSAvLyB1c3RhclxceDAwXG5jb25zdCBVU1RBUl9WRVIgPSBiNGEuZnJvbShbWkVST19PRkZTRVQsIFpFUk9fT0ZGU0VUXSlcbmNvbnN0IEdOVV9NQUdJQyA9IGI0YS5mcm9tKFsweDc1LCAweDczLCAweDc0LCAweDYxLCAweDcyLCAweDIwXSkgLy8gdXN0YXJcXHgyMFxuY29uc3QgR05VX1ZFUiA9IGI0YS5mcm9tKFsweDIwLCAweDAwXSlcbmNvbnN0IE1BU0sgPSAwbzc3NzdcbmNvbnN0IE1BR0lDX09GRlNFVCA9IDI1N1xuY29uc3QgVkVSU0lPTl9PRkZTRVQgPSAyNjNcblxuZXhwb3J0cy5kZWNvZGVMb25nUGF0aCA9IGZ1bmN0aW9uIGRlY29kZUxvbmdQYXRoIChidWYsIGVuY29kaW5nKSB7XG4gIHJldHVybiBkZWNvZGVTdHIoYnVmLCAwLCBidWYubGVuZ3RoLCBlbmNvZGluZylcbn1cblxuZXhwb3J0cy5lbmNvZGVQYXggPSBmdW5jdGlvbiBlbmNvZGVQYXggKG9wdHMpIHsgLy8gVE9ETzogZW5jb2RlIG1vcmUgc3R1ZmYgaW4gcGF4XG4gIGxldCByZXN1bHQgPSAnJ1xuICBpZiAob3B0cy5uYW1lKSByZXN1bHQgKz0gYWRkTGVuZ3RoKCcgcGF0aD0nICsgb3B0cy5uYW1lICsgJ1xcbicpXG4gIGlmIChvcHRzLmxpbmtuYW1lKSByZXN1bHQgKz0gYWRkTGVuZ3RoKCcgbGlua3BhdGg9JyArIG9wdHMubGlua25hbWUgKyAnXFxuJylcbiAgY29uc3QgcGF4ID0gb3B0cy5wYXhcbiAgaWYgKHBheCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBheCkge1xuICAgICAgcmVzdWx0ICs9IGFkZExlbmd0aCgnICcgKyBrZXkgKyAnPScgKyBwYXhba2V5XSArICdcXG4nKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYjRhLmZyb20ocmVzdWx0KVxufVxuXG5leHBvcnRzLmRlY29kZVBheCA9IGZ1bmN0aW9uIGRlY29kZVBheCAoYnVmKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgd2hpbGUgKGJ1Zi5sZW5ndGgpIHtcbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZSAoaSA8IGJ1Zi5sZW5ndGggJiYgYnVmW2ldICE9PSAzMikgaSsrXG4gICAgY29uc3QgbGVuID0gcGFyc2VJbnQoYjRhLnRvU3RyaW5nKGJ1Zi5zdWJhcnJheSgwLCBpKSksIDEwKVxuICAgIGlmICghbGVuKSByZXR1cm4gcmVzdWx0XG5cbiAgICBjb25zdCBiID0gYjRhLnRvU3RyaW5nKGJ1Zi5zdWJhcnJheShpICsgMSwgbGVuIC0gMSkpXG4gICAgY29uc3Qga2V5SW5kZXggPSBiLmluZGV4T2YoJz0nKVxuICAgIGlmIChrZXlJbmRleCA9PT0gLTEpIHJldHVybiByZXN1bHRcbiAgICByZXN1bHRbYi5zbGljZSgwLCBrZXlJbmRleCldID0gYi5zbGljZShrZXlJbmRleCArIDEpXG5cbiAgICBidWYgPSBidWYuc3ViYXJyYXkobGVuKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAob3B0cykge1xuICBjb25zdCBidWYgPSBiNGEuYWxsb2MoNTEyKVxuICBsZXQgbmFtZSA9IG9wdHMubmFtZVxuICBsZXQgcHJlZml4ID0gJydcblxuICBpZiAob3B0cy50eXBlZmxhZyA9PT0gNSAmJiBuYW1lW25hbWUubGVuZ3RoIC0gMV0gIT09ICcvJykgbmFtZSArPSAnLydcbiAgaWYgKGI0YS5ieXRlTGVuZ3RoKG5hbWUpICE9PSBuYW1lLmxlbmd0aCkgcmV0dXJuIG51bGwgLy8gdXRmLThcblxuICB3aGlsZSAoYjRhLmJ5dGVMZW5ndGgobmFtZSkgPiAxMDApIHtcbiAgICBjb25zdCBpID0gbmFtZS5pbmRleE9mKCcvJylcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybiBudWxsXG4gICAgcHJlZml4ICs9IHByZWZpeCA/ICcvJyArIG5hbWUuc2xpY2UoMCwgaSkgOiBuYW1lLnNsaWNlKDAsIGkpXG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpXG4gIH1cblxuICBpZiAoYjRhLmJ5dGVMZW5ndGgobmFtZSkgPiAxMDAgfHwgYjRhLmJ5dGVMZW5ndGgocHJlZml4KSA+IDE1NSkgcmV0dXJuIG51bGxcbiAgaWYgKG9wdHMubGlua25hbWUgJiYgYjRhLmJ5dGVMZW5ndGgob3B0cy5saW5rbmFtZSkgPiAxMDApIHJldHVybiBudWxsXG5cbiAgYjRhLndyaXRlKGJ1ZiwgbmFtZSlcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMubW9kZSAmIE1BU0ssIDYpLCAxMDApXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLnVpZCwgNiksIDEwOClcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMuZ2lkLCA2KSwgMTE2KVxuICBlbmNvZGVTaXplKG9wdHMuc2l6ZSwgYnVmLCAxMjQpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdCgob3B0cy5tdGltZS5nZXRUaW1lKCkgLyAxMDAwKSB8IDAsIDExKSwgMTM2KVxuXG4gIGJ1ZlsxNTZdID0gWkVST19PRkZTRVQgKyB0b1R5cGVmbGFnKG9wdHMudHlwZSlcblxuICBpZiAob3B0cy5saW5rbmFtZSkgYjRhLndyaXRlKGJ1Ziwgb3B0cy5saW5rbmFtZSwgMTU3KVxuXG4gIGI0YS5jb3B5KFVTVEFSX01BR0lDLCBidWYsIE1BR0lDX09GRlNFVClcbiAgYjRhLmNvcHkoVVNUQVJfVkVSLCBidWYsIFZFUlNJT05fT0ZGU0VUKVxuICBpZiAob3B0cy51bmFtZSkgYjRhLndyaXRlKGJ1Ziwgb3B0cy51bmFtZSwgMjY1KVxuICBpZiAob3B0cy5nbmFtZSkgYjRhLndyaXRlKGJ1Ziwgb3B0cy5nbmFtZSwgMjk3KVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3Qob3B0cy5kZXZtYWpvciB8fCAwLCA2KSwgMzI5KVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3Qob3B0cy5kZXZtaW5vciB8fCAwLCA2KSwgMzM3KVxuXG4gIGlmIChwcmVmaXgpIGI0YS53cml0ZShidWYsIHByZWZpeCwgMzQ1KVxuXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChja3N1bShidWYpLCA2KSwgMTQ4KVxuXG4gIHJldHVybiBidWZcbn1cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUgKGJ1ZiwgZmlsZW5hbWVFbmNvZGluZywgYWxsb3dVbmtub3duRm9ybWF0KSB7XG4gIGxldCB0eXBlZmxhZyA9IGJ1ZlsxNTZdID09PSAwID8gMCA6IGJ1ZlsxNTZdIC0gWkVST19PRkZTRVRcblxuICBsZXQgbmFtZSA9IGRlY29kZVN0cihidWYsIDAsIDEwMCwgZmlsZW5hbWVFbmNvZGluZylcbiAgY29uc3QgbW9kZSA9IGRlY29kZU9jdChidWYsIDEwMCwgOClcbiAgY29uc3QgdWlkID0gZGVjb2RlT2N0KGJ1ZiwgMTA4LCA4KVxuICBjb25zdCBnaWQgPSBkZWNvZGVPY3QoYnVmLCAxMTYsIDgpXG4gIGNvbnN0IHNpemUgPSBkZWNvZGVPY3QoYnVmLCAxMjQsIDEyKVxuICBjb25zdCBtdGltZSA9IGRlY29kZU9jdChidWYsIDEzNiwgMTIpXG4gIGNvbnN0IHR5cGUgPSB0b1R5cGUodHlwZWZsYWcpXG4gIGNvbnN0IGxpbmtuYW1lID0gYnVmWzE1N10gPT09IDAgPyBudWxsIDogZGVjb2RlU3RyKGJ1ZiwgMTU3LCAxMDAsIGZpbGVuYW1lRW5jb2RpbmcpXG4gIGNvbnN0IHVuYW1lID0gZGVjb2RlU3RyKGJ1ZiwgMjY1LCAzMilcbiAgY29uc3QgZ25hbWUgPSBkZWNvZGVTdHIoYnVmLCAyOTcsIDMyKVxuICBjb25zdCBkZXZtYWpvciA9IGRlY29kZU9jdChidWYsIDMyOSwgOClcbiAgY29uc3QgZGV2bWlub3IgPSBkZWNvZGVPY3QoYnVmLCAzMzcsIDgpXG5cbiAgY29uc3QgYyA9IGNrc3VtKGJ1ZilcblxuICAvLyBjaGVja3N1bSBpcyBzdGlsbCBpbml0aWFsIHZhbHVlIGlmIGhlYWRlciB3YXMgbnVsbC5cbiAgaWYgKGMgPT09IDggKiAzMikgcmV0dXJuIG51bGxcblxuICAvLyB2YWxpZCBjaGVja3N1bVxuICBpZiAoYyAhPT0gZGVjb2RlT2N0KGJ1ZiwgMTQ4LCA4KSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhciBoZWFkZXIuIE1heWJlIHRoZSB0YXIgaXMgY29ycnVwdGVkIG9yIGl0IG5lZWRzIHRvIGJlIGd1bnppcHBlZD8nKVxuXG4gIGlmIChpc1VTVEFSKGJ1ZikpIHtcbiAgICAvLyB1c3RhciAocG9zaXgpIGZvcm1hdC5cbiAgICAvLyBwcmVwZW5kIHByZWZpeCwgaWYgcHJlc2VudC5cbiAgICBpZiAoYnVmWzM0NV0pIG5hbWUgPSBkZWNvZGVTdHIoYnVmLCAzNDUsIDE1NSwgZmlsZW5hbWVFbmNvZGluZykgKyAnLycgKyBuYW1lXG4gIH0gZWxzZSBpZiAoaXNHTlUoYnVmKSkge1xuICAgIC8vICdnbnUnLydvbGRnbnUnIGZvcm1hdC4gU2ltaWxhciB0byB1c3RhciwgYnV0IGhhcyBzdXBwb3J0IGZvciBpbmNyZW1lbnRhbCBhbmRcbiAgICAvLyBtdWx0aS12b2x1bWUgdGFyYmFsbHMuXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFhbGxvd1Vua25vd25Gb3JtYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXIgaGVhZGVyOiB1bmtub3duIGZvcm1hdC4nKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRvIHN1cHBvcnQgb2xkIHRhciB2ZXJzaW9ucyB0aGF0IHVzZSB0cmFpbGluZyAvIHRvIGluZGljYXRlIGRpcnNcbiAgaWYgKHR5cGVmbGFnID09PSAwICYmIG5hbWUgJiYgbmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnLycpIHR5cGVmbGFnID0gNVxuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBtb2RlLFxuICAgIHVpZCxcbiAgICBnaWQsXG4gICAgc2l6ZSxcbiAgICBtdGltZTogbmV3IERhdGUoMTAwMCAqIG10aW1lKSxcbiAgICB0eXBlLFxuICAgIGxpbmtuYW1lLFxuICAgIHVuYW1lLFxuICAgIGduYW1lLFxuICAgIGRldm1ham9yLFxuICAgIGRldm1pbm9yLFxuICAgIHBheDogbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVVNUQVIgKGJ1Zikge1xuICByZXR1cm4gYjRhLmVxdWFscyhVU1RBUl9NQUdJQywgYnVmLnN1YmFycmF5KE1BR0lDX09GRlNFVCwgTUFHSUNfT0ZGU0VUICsgNikpXG59XG5cbmZ1bmN0aW9uIGlzR05VIChidWYpIHtcbiAgcmV0dXJuIGI0YS5lcXVhbHMoR05VX01BR0lDLCBidWYuc3ViYXJyYXkoTUFHSUNfT0ZGU0VULCBNQUdJQ19PRkZTRVQgKyA2KSkgJiZcbiAgICBiNGEuZXF1YWxzKEdOVV9WRVIsIGJ1Zi5zdWJhcnJheShWRVJTSU9OX09GRlNFVCwgVkVSU0lPTl9PRkZTRVQgKyAyKSlcbn1cblxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXggLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiB0b1R5cGUgKGZsYWcpIHtcbiAgc3dpdGNoIChmbGFnKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuICdmaWxlJ1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAnbGluaydcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gJ3N5bWxpbmsnXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuICdjaGFyYWN0ZXItZGV2aWNlJ1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiAnYmxvY2stZGV2aWNlJ1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiAnZGlyZWN0b3J5J1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiAnZmlmbydcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gJ2NvbnRpZ3VvdXMtZmlsZSdcbiAgICBjYXNlIDcyOlxuICAgICAgcmV0dXJuICdwYXgtaGVhZGVyJ1xuICAgIGNhc2UgNTU6XG4gICAgICByZXR1cm4gJ3BheC1nbG9iYWwtaGVhZGVyJ1xuICAgIGNhc2UgMjc6XG4gICAgICByZXR1cm4gJ2dudS1sb25nLWxpbmstcGF0aCdcbiAgICBjYXNlIDI4OlxuICAgIGNhc2UgMzA6XG4gICAgICByZXR1cm4gJ2dudS1sb25nLXBhdGgnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiB0b1R5cGVmbGFnIChmbGFnKSB7XG4gIHN3aXRjaCAoZmxhZykge1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIDBcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHJldHVybiAxXG4gICAgY2FzZSAnc3ltbGluayc6XG4gICAgICByZXR1cm4gMlxuICAgIGNhc2UgJ2NoYXJhY3Rlci1kZXZpY2UnOlxuICAgICAgcmV0dXJuIDNcbiAgICBjYXNlICdibG9jay1kZXZpY2UnOlxuICAgICAgcmV0dXJuIDRcbiAgICBjYXNlICdkaXJlY3RvcnknOlxuICAgICAgcmV0dXJuIDVcbiAgICBjYXNlICdmaWZvJzpcbiAgICAgIHJldHVybiA2XG4gICAgY2FzZSAnY29udGlndW91cy1maWxlJzpcbiAgICAgIHJldHVybiA3XG4gICAgY2FzZSAncGF4LWhlYWRlcic6XG4gICAgICByZXR1cm4gNzJcbiAgfVxuXG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKGJsb2NrLCBudW0sIG9mZnNldCwgZW5kKSB7XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCsrKSB7XG4gICAgaWYgKGJsb2NrW29mZnNldF0gPT09IG51bSkgcmV0dXJuIG9mZnNldFxuICB9XG4gIHJldHVybiBlbmRcbn1cblxuZnVuY3Rpb24gY2tzdW0gKGJsb2NrKSB7XG4gIGxldCBzdW0gPSA4ICogMzJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNDg7IGkrKykgc3VtICs9IGJsb2NrW2ldXG4gIGZvciAobGV0IGogPSAxNTY7IGogPCA1MTI7IGorKykgc3VtICs9IGJsb2NrW2pdXG4gIHJldHVybiBzdW1cbn1cblxuZnVuY3Rpb24gZW5jb2RlT2N0ICh2YWwsIG4pIHtcbiAgdmFsID0gdmFsLnRvU3RyaW5nKDgpXG4gIGlmICh2YWwubGVuZ3RoID4gbikgcmV0dXJuIFNFVkVOUy5zbGljZSgwLCBuKSArICcgJ1xuICByZXR1cm4gWkVST1Muc2xpY2UoMCwgbiAtIHZhbC5sZW5ndGgpICsgdmFsICsgJyAnXG59XG5cbmZ1bmN0aW9uIGVuY29kZVNpemVCaW4gKG51bSwgYnVmLCBvZmYpIHtcbiAgYnVmW29mZl0gPSAweDgwXG4gIGZvciAobGV0IGkgPSAxMTsgaSA+IDA7IGktLSkge1xuICAgIGJ1ZltvZmYgKyBpXSA9IG51bSAmIDB4ZmZcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIDB4MTAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZVNpemUgKG51bSwgYnVmLCBvZmYpIHtcbiAgaWYgKG51bS50b1N0cmluZyg4KS5sZW5ndGggPiAxMSkge1xuICAgIGVuY29kZVNpemVCaW4obnVtLCBidWYsIG9mZilcbiAgfSBlbHNlIHtcbiAgICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3QobnVtLCAxMSksIG9mZilcbiAgfVxufVxuXG4vKiBDb3BpZWQgZnJvbSB0aGUgbm9kZS10YXIgcmVwbyBhbmQgbW9kaWZpZWQgdG8gbWVldFxuICogdGFyLXN0cmVhbSBjb2Rpbmcgc3RhbmRhcmQuXG4gKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25vZGUtdGFyL2Jsb2IvNTFiNjYyN2ExZjM1N2QyZWI0MzNlNzM3OGU1ZjA1ZTgzYjdhYTZjZC9saWIvaGVhZGVyLmpzI0wzNDlcbiAqL1xuZnVuY3Rpb24gcGFyc2UyNTYgKGJ1Zikge1xuICAvLyBmaXJzdCBieXRlIE1VU1QgYmUgZWl0aGVyIDgwIG9yIEZGXG4gIC8vIDgwIGZvciBwb3NpdGl2ZSwgRkYgZm9yIDIncyBjb21wXG4gIGxldCBwb3NpdGl2ZVxuICBpZiAoYnVmWzBdID09PSAweDgwKSBwb3NpdGl2ZSA9IHRydWVcbiAgZWxzZSBpZiAoYnVmWzBdID09PSAweEZGKSBwb3NpdGl2ZSA9IGZhbHNlXG4gIGVsc2UgcmV0dXJuIG51bGxcblxuICAvLyBidWlsZCB1cCBhIGJhc2UtMjU2IHR1cGxlIGZyb20gdGhlIGxlYXN0IHNpZyB0byB0aGUgaGlnaGVzdFxuICBjb25zdCB0dXBsZSA9IFtdXG4gIGxldCBpXG4gIGZvciAoaSA9IGJ1Zi5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3QgYnl0ZSA9IGJ1ZltpXVxuICAgIGlmIChwb3NpdGl2ZSkgdHVwbGUucHVzaChieXRlKVxuICAgIGVsc2UgdHVwbGUucHVzaCgweEZGIC0gYnl0ZSlcbiAgfVxuXG4gIGxldCBzdW0gPSAwXG4gIGNvbnN0IGwgPSB0dXBsZS5sZW5ndGhcbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHN1bSArPSB0dXBsZVtpXSAqIE1hdGgucG93KDI1NiwgaSlcbiAgfVxuXG4gIHJldHVybiBwb3NpdGl2ZSA/IHN1bSA6IC0xICogc3VtXG59XG5cbmZ1bmN0aW9uIGRlY29kZU9jdCAodmFsLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YWwgPSB2YWwuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpXG4gIG9mZnNldCA9IDBcblxuICAvLyBJZiBwcmVmaXhlZCB3aXRoIDB4ODAgdGhlbiBwYXJzZSBhcyBhIGJhc2UtMjU2IGludGVnZXJcbiAgaWYgKHZhbFtvZmZzZXRdICYgMHg4MCkge1xuICAgIHJldHVybiBwYXJzZTI1Nih2YWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgdGFyIGNhbiBwcmVmaXggd2l0aCBzcGFjZXNcbiAgICB3aGlsZSAob2Zmc2V0IDwgdmFsLmxlbmd0aCAmJiB2YWxbb2Zmc2V0XSA9PT0gMzIpIG9mZnNldCsrXG4gICAgY29uc3QgZW5kID0gY2xhbXAoaW5kZXhPZih2YWwsIDMyLCBvZmZzZXQsIHZhbC5sZW5ndGgpLCB2YWwubGVuZ3RoLCB2YWwubGVuZ3RoKVxuICAgIHdoaWxlIChvZmZzZXQgPCBlbmQgJiYgdmFsW29mZnNldF0gPT09IDApIG9mZnNldCsrXG4gICAgaWYgKGVuZCA9PT0gb2Zmc2V0KSByZXR1cm4gMFxuICAgIHJldHVybiBwYXJzZUludChiNGEudG9TdHJpbmcodmFsLnN1YmFycmF5KG9mZnNldCwgZW5kKSksIDgpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlU3RyICh2YWwsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICByZXR1cm4gYjRhLnRvU3RyaW5nKHZhbC5zdWJhcnJheShvZmZzZXQsIGluZGV4T2YodmFsLCAwLCBvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWRkTGVuZ3RoIChzdHIpIHtcbiAgY29uc3QgbGVuID0gYjRhLmJ5dGVMZW5ndGgoc3RyKVxuICBsZXQgZGlnaXRzID0gTWF0aC5mbG9vcihNYXRoLmxvZyhsZW4pIC8gTWF0aC5sb2coMTApKSArIDFcbiAgaWYgKGxlbiArIGRpZ2l0cyA+PSBNYXRoLnBvdygxMCwgZGlnaXRzKSkgZGlnaXRzKytcblxuICByZXR1cm4gKGxlbiArIGRpZ2l0cykgKyBzdHJcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/tar-stream/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.extract = __webpack_require__(/*! ./extract */ \"(rsc)/./node_modules/tar-stream/extract.js\")\nexports.pack = __webpack_require__(/*! ./pack */ \"(rsc)/./node_modules/tar-stream/pack.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvR0FBc0M7QUFDdEMsMkZBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY291cnNld29yay1tYW5hZ2VtZW50Ly4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vaW5kZXguanM/ODAzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmV4dHJhY3QgPSByZXF1aXJlKCcuL2V4dHJhY3QnKVxuZXhwb3J0cy5wYWNrID0gcmVxdWlyZSgnLi9wYWNrJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/pack.js":
/*!*****************************************!*\
  !*** ./node_modules/tar-stream/pack.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Readable, Writable, getStreamError } = __webpack_require__(/*! streamx */ \"(rsc)/./node_modules/streamx/index.js\")\nconst b4a = __webpack_require__(/*! b4a */ \"(rsc)/./node_modules/b4a/index.js\")\n\nconst constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/tar-stream/constants.js\")\nconst headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/tar-stream/headers.js\")\n\nconst DMODE = 0o755\nconst FMODE = 0o644\n\nconst END_OF_TAR = b4a.alloc(1024)\n\nclass Sink extends Writable {\n  constructor (pack, header, callback) {\n    super({ mapWritable, eagerOpen: true })\n\n    this.written = 0\n    this.header = header\n\n    this._callback = callback\n    this._linkname = null\n    this._isLinkname = header.type === 'symlink' && !header.linkname\n    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file'\n    this._finished = false\n    this._pack = pack\n    this._openCallback = null\n\n    if (this._pack._stream === null) this._pack._stream = this\n    else this._pack._pending.push(this)\n  }\n\n  _open (cb) {\n    this._openCallback = cb\n    if (this._pack._stream === this) this._continueOpen()\n  }\n\n  _continuePack (err) {\n    if (this._callback === null) return\n\n    const callback = this._callback\n    this._callback = null\n\n    callback(err)\n  }\n\n  _continueOpen () {\n    if (this._pack._stream === null) this._pack._stream = this\n\n    const cb = this._openCallback\n    this._openCallback = null\n    if (cb === null) return\n\n    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))\n    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))\n\n    this._pack._stream = this\n\n    if (!this._isLinkname) {\n      this._pack._encode(this.header)\n    }\n\n    if (this._isVoid) {\n      this._finish()\n      this._continuePack(null)\n    }\n\n    cb(null)\n  }\n\n  _write (data, cb) {\n    if (this._isLinkname) {\n      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data\n      return cb(null)\n    }\n\n    if (this._isVoid) {\n      if (data.byteLength > 0) {\n        return cb(new Error('No body allowed for this entry'))\n      }\n      return cb()\n    }\n\n    this.written += data.byteLength\n    if (this._pack.push(data)) return cb()\n    this._pack._drain = cb\n  }\n\n  _finish () {\n    if (this._finished) return\n    this._finished = true\n\n    if (this._isLinkname) {\n      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : ''\n      this._pack._encode(this.header)\n    }\n\n    overflow(this._pack, this.header.size)\n\n    this._pack._done(this)\n  }\n\n  _final (cb) {\n    if (this.written !== this.header.size) { // corrupting tar\n      return cb(new Error('Size mismatch'))\n    }\n\n    this._finish()\n    cb(null)\n  }\n\n  _getError () {\n    return getStreamError(this) || new Error('tar entry destroyed')\n  }\n\n  _predestroy () {\n    this._pack.destroy(this._getError())\n  }\n\n  _destroy (cb) {\n    this._pack._done(this)\n\n    this._continuePack(this._finished ? null : this._getError())\n\n    cb()\n  }\n}\n\nclass Pack extends Readable {\n  constructor (opts) {\n    super(opts)\n    this._drain = noop\n    this._finalized = false\n    this._finalizing = false\n    this._pending = []\n    this._stream = null\n  }\n\n  entry (header, buffer, callback) {\n    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')\n\n    if (typeof buffer === 'function') {\n      callback = buffer\n      buffer = null\n    }\n\n    if (!callback) callback = noop\n\n    if (!header.size || header.type === 'symlink') header.size = 0\n    if (!header.type) header.type = modeToType(header.mode)\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n    if (!header.uid) header.uid = 0\n    if (!header.gid) header.gid = 0\n    if (!header.mtime) header.mtime = new Date()\n\n    if (typeof buffer === 'string') buffer = b4a.from(buffer)\n\n    const sink = new Sink(this, header, callback)\n\n    if (b4a.isBuffer(buffer)) {\n      header.size = buffer.byteLength\n      sink.write(buffer)\n      sink.end()\n      return sink\n    }\n\n    if (sink._isVoid) {\n      return sink\n    }\n\n    return sink\n  }\n\n  finalize () {\n    if (this._stream || this._pending.length > 0) {\n      this._finalizing = true\n      return\n    }\n\n    if (this._finalized) return\n    this._finalized = true\n\n    this.push(END_OF_TAR)\n    this.push(null)\n  }\n\n  _done (stream) {\n    if (stream !== this._stream) return\n\n    this._stream = null\n\n    if (this._finalizing) this.finalize()\n    if (this._pending.length) this._pending.shift()._continueOpen()\n  }\n\n  _encode (header) {\n    if (!header.pax) {\n      const buf = headers.encode(header)\n      if (buf) {\n        this.push(buf)\n        return\n      }\n    }\n    this._encodePax(header)\n  }\n\n  _encodePax (header) {\n    const paxHeader = headers.encodePax({\n      name: header.name,\n      linkname: header.linkname,\n      pax: header.pax\n    })\n\n    const newHeader = {\n      name: 'PaxHeader',\n      mode: header.mode,\n      uid: header.uid,\n      gid: header.gid,\n      size: paxHeader.byteLength,\n      mtime: header.mtime,\n      type: 'pax-header',\n      linkname: header.linkname && 'PaxHeader',\n      uname: header.uname,\n      gname: header.gname,\n      devmajor: header.devmajor,\n      devminor: header.devminor\n    }\n\n    this.push(headers.encode(newHeader))\n    this.push(paxHeader)\n    overflow(this, paxHeader.byteLength)\n\n    newHeader.size = header.size\n    newHeader.type = header.type\n    this.push(headers.encode(newHeader))\n  }\n\n  _doDrain () {\n    const drain = this._drain\n    this._drain = noop\n    drain()\n  }\n\n  _predestroy () {\n    const err = getStreamError(this)\n\n    if (this._stream) this._stream.destroy(err)\n\n    while (this._pending.length) {\n      const stream = this._pending.shift()\n      stream.destroy(err)\n      stream._continueOpen()\n    }\n\n    this._doDrain()\n  }\n\n  _read (cb) {\n    this._doDrain()\n    cb()\n  }\n}\n\nmodule.exports = function pack (opts) {\n  return new Pack(opts)\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nfunction noop () {}\n\nfunction overflow (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.subarray(0, 512 - size))\n}\n\nfunction mapWritable (buf) {\n  return b4a.isBuffer(buf) ? buf : b4a.from(buf)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9wYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyxzREFBUztBQUNoRSxZQUFZLG1CQUFPLENBQUMsOENBQUs7O0FBRXpCLGtCQUFrQixtQkFBTyxDQUFDLGlFQUFhO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Vyc2V3b3JrLW1hbmFnZW1lbnQvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9wYWNrLmpzPzE2NWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBSZWFkYWJsZSwgV3JpdGFibGUsIGdldFN0cmVhbUVycm9yIH0gPSByZXF1aXJlKCdzdHJlYW14JylcbmNvbnN0IGI0YSA9IHJlcXVpcmUoJ2I0YScpXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGhlYWRlcnMgPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuXG5jb25zdCBETU9ERSA9IDBvNzU1XG5jb25zdCBGTU9ERSA9IDBvNjQ0XG5cbmNvbnN0IEVORF9PRl9UQVIgPSBiNGEuYWxsb2MoMTAyNClcblxuY2xhc3MgU2luayBleHRlbmRzIFdyaXRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHBhY2ssIGhlYWRlciwgY2FsbGJhY2spIHtcbiAgICBzdXBlcih7IG1hcFdyaXRhYmxlLCBlYWdlck9wZW46IHRydWUgfSlcblxuICAgIHRoaXMud3JpdHRlbiA9IDBcbiAgICB0aGlzLmhlYWRlciA9IGhlYWRlclxuXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuX2xpbmtuYW1lID0gbnVsbFxuICAgIHRoaXMuX2lzTGlua25hbWUgPSBoZWFkZXIudHlwZSA9PT0gJ3N5bWxpbmsnICYmICFoZWFkZXIubGlua25hbWVcbiAgICB0aGlzLl9pc1ZvaWQgPSBoZWFkZXIudHlwZSAhPT0gJ2ZpbGUnICYmIGhlYWRlci50eXBlICE9PSAnY29udGlndW91cy1maWxlJ1xuICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2VcbiAgICB0aGlzLl9wYWNrID0gcGFja1xuICAgIHRoaXMuX29wZW5DYWxsYmFjayA9IG51bGxcblxuICAgIGlmICh0aGlzLl9wYWNrLl9zdHJlYW0gPT09IG51bGwpIHRoaXMuX3BhY2suX3N0cmVhbSA9IHRoaXNcbiAgICBlbHNlIHRoaXMuX3BhY2suX3BlbmRpbmcucHVzaCh0aGlzKVxuICB9XG5cbiAgX29wZW4gKGNiKSB7XG4gICAgdGhpcy5fb3BlbkNhbGxiYWNrID0gY2JcbiAgICBpZiAodGhpcy5fcGFjay5fc3RyZWFtID09PSB0aGlzKSB0aGlzLl9jb250aW51ZU9wZW4oKVxuICB9XG5cbiAgX2NvbnRpbnVlUGFjayAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrID09PSBudWxsKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2tcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxuXG4gIF9jb250aW51ZU9wZW4gKCkge1xuICAgIGlmICh0aGlzLl9wYWNrLl9zdHJlYW0gPT09IG51bGwpIHRoaXMuX3BhY2suX3N0cmVhbSA9IHRoaXNcblxuICAgIGNvbnN0IGNiID0gdGhpcy5fb3BlbkNhbGxiYWNrXG4gICAgdGhpcy5fb3BlbkNhbGxiYWNrID0gbnVsbFxuICAgIGlmIChjYiA9PT0gbnVsbCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5fcGFjay5kZXN0cm95aW5nKSByZXR1cm4gY2IobmV3IEVycm9yKCdwYWNrIHN0cmVhbSBkZXN0cm95ZWQnKSlcbiAgICBpZiAodGhpcy5fcGFjay5fZmluYWxpemVkKSByZXR1cm4gY2IobmV3IEVycm9yKCdwYWNrIHN0cmVhbSBpcyBhbHJlYWR5IGZpbmFsaXplZCcpKVxuXG4gICAgdGhpcy5fcGFjay5fc3RyZWFtID0gdGhpc1xuXG4gICAgaWYgKCF0aGlzLl9pc0xpbmtuYW1lKSB7XG4gICAgICB0aGlzLl9wYWNrLl9lbmNvZGUodGhpcy5oZWFkZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVm9pZCkge1xuICAgICAgdGhpcy5fZmluaXNoKClcbiAgICAgIHRoaXMuX2NvbnRpbnVlUGFjayhudWxsKVxuICAgIH1cblxuICAgIGNiKG51bGwpXG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX2lzTGlua25hbWUpIHtcbiAgICAgIHRoaXMuX2xpbmtuYW1lID0gdGhpcy5fbGlua25hbWUgPyBiNGEuY29uY2F0KFt0aGlzLl9saW5rbmFtZSwgZGF0YV0pIDogZGF0YVxuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVm9pZCkge1xuICAgICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gYm9keSBhbGxvd2VkIGZvciB0aGlzIGVudHJ5JykpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoKVxuICAgIH1cblxuICAgIHRoaXMud3JpdHRlbiArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICBpZiAodGhpcy5fcGFjay5wdXNoKGRhdGEpKSByZXR1cm4gY2IoKVxuICAgIHRoaXMuX3BhY2suX2RyYWluID0gY2JcbiAgfVxuXG4gIF9maW5pc2ggKCkge1xuICAgIGlmICh0aGlzLl9maW5pc2hlZCkgcmV0dXJuXG4gICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlXG5cbiAgICBpZiAodGhpcy5faXNMaW5rbmFtZSkge1xuICAgICAgdGhpcy5oZWFkZXIubGlua25hbWUgPSB0aGlzLl9saW5rbmFtZSA/IGI0YS50b1N0cmluZyh0aGlzLl9saW5rbmFtZSwgJ3V0Zi04JykgOiAnJ1xuICAgICAgdGhpcy5fcGFjay5fZW5jb2RlKHRoaXMuaGVhZGVyKVxuICAgIH1cblxuICAgIG92ZXJmbG93KHRoaXMuX3BhY2ssIHRoaXMuaGVhZGVyLnNpemUpXG5cbiAgICB0aGlzLl9wYWNrLl9kb25lKHRoaXMpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgaWYgKHRoaXMud3JpdHRlbiAhPT0gdGhpcy5oZWFkZXIuc2l6ZSkgeyAvLyBjb3JydXB0aW5nIHRhclxuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU2l6ZSBtaXNtYXRjaCcpKVxuICAgIH1cblxuICAgIHRoaXMuX2ZpbmlzaCgpXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9nZXRFcnJvciAoKSB7XG4gICAgcmV0dXJuIGdldFN0cmVhbUVycm9yKHRoaXMpIHx8IG5ldyBFcnJvcigndGFyIGVudHJ5IGRlc3Ryb3llZCcpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fcGFjay5kZXN0cm95KHRoaXMuX2dldEVycm9yKCkpXG4gIH1cblxuICBfZGVzdHJveSAoY2IpIHtcbiAgICB0aGlzLl9wYWNrLl9kb25lKHRoaXMpXG5cbiAgICB0aGlzLl9jb250aW51ZVBhY2sodGhpcy5fZmluaXNoZWQgPyBudWxsIDogdGhpcy5fZ2V0RXJyb3IoKSlcblxuICAgIGNiKClcbiAgfVxufVxuXG5jbGFzcyBQYWNrIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5fZHJhaW4gPSBub29wXG4gICAgdGhpcy5fZmluYWxpemVkID0gZmFsc2VcbiAgICB0aGlzLl9maW5hbGl6aW5nID0gZmFsc2VcbiAgICB0aGlzLl9wZW5kaW5nID0gW11cbiAgICB0aGlzLl9zdHJlYW0gPSBudWxsXG4gIH1cblxuICBlbnRyeSAoaGVhZGVyLCBidWZmZXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCB8fCB0aGlzLmRlc3Ryb3lpbmcpIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBmaW5hbGl6ZWQgb3IgZGVzdHJveWVkJylcblxuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGJ1ZmZlclxuICAgICAgYnVmZmVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gbm9vcFxuXG4gICAgaWYgKCFoZWFkZXIuc2l6ZSB8fCBoZWFkZXIudHlwZSA9PT0gJ3N5bWxpbmsnKSBoZWFkZXIuc2l6ZSA9IDBcbiAgICBpZiAoIWhlYWRlci50eXBlKSBoZWFkZXIudHlwZSA9IG1vZGVUb1R5cGUoaGVhZGVyLm1vZGUpXG4gICAgaWYgKCFoZWFkZXIubW9kZSkgaGVhZGVyLm1vZGUgPSBoZWFkZXIudHlwZSA9PT0gJ2RpcmVjdG9yeScgPyBETU9ERSA6IEZNT0RFXG4gICAgaWYgKCFoZWFkZXIudWlkKSBoZWFkZXIudWlkID0gMFxuICAgIGlmICghaGVhZGVyLmdpZCkgaGVhZGVyLmdpZCA9IDBcbiAgICBpZiAoIWhlYWRlci5tdGltZSkgaGVhZGVyLm10aW1lID0gbmV3IERhdGUoKVxuXG4gICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSBidWZmZXIgPSBiNGEuZnJvbShidWZmZXIpXG5cbiAgICBjb25zdCBzaW5rID0gbmV3IFNpbmsodGhpcywgaGVhZGVyLCBjYWxsYmFjaylcblxuICAgIGlmIChiNGEuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgaGVhZGVyLnNpemUgPSBidWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgc2luay53cml0ZShidWZmZXIpXG4gICAgICBzaW5rLmVuZCgpXG4gICAgICByZXR1cm4gc2lua1xuICAgIH1cblxuICAgIGlmIChzaW5rLl9pc1ZvaWQpIHtcbiAgICAgIHJldHVybiBzaW5rXG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbmtcbiAgfVxuXG4gIGZpbmFsaXplICgpIHtcbiAgICBpZiAodGhpcy5fc3RyZWFtIHx8IHRoaXMuX3BlbmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fZmluYWxpemluZyA9IHRydWVcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9maW5hbGl6ZWQpIHJldHVyblxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICAgIHRoaXMucHVzaChFTkRfT0ZfVEFSKVxuICAgIHRoaXMucHVzaChudWxsKVxuICB9XG5cbiAgX2RvbmUgKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0gIT09IHRoaXMuX3N0cmVhbSkgcmV0dXJuXG5cbiAgICB0aGlzLl9zdHJlYW0gPSBudWxsXG5cbiAgICBpZiAodGhpcy5fZmluYWxpemluZykgdGhpcy5maW5hbGl6ZSgpXG4gICAgaWYgKHRoaXMuX3BlbmRpbmcubGVuZ3RoKSB0aGlzLl9wZW5kaW5nLnNoaWZ0KCkuX2NvbnRpbnVlT3BlbigpXG4gIH1cblxuICBfZW5jb2RlIChoZWFkZXIpIHtcbiAgICBpZiAoIWhlYWRlci5wYXgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IGhlYWRlcnMuZW5jb2RlKGhlYWRlcilcbiAgICAgIGlmIChidWYpIHtcbiAgICAgICAgdGhpcy5wdXNoKGJ1ZilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2VuY29kZVBheChoZWFkZXIpXG4gIH1cblxuICBfZW5jb2RlUGF4IChoZWFkZXIpIHtcbiAgICBjb25zdCBwYXhIZWFkZXIgPSBoZWFkZXJzLmVuY29kZVBheCh7XG4gICAgICBuYW1lOiBoZWFkZXIubmFtZSxcbiAgICAgIGxpbmtuYW1lOiBoZWFkZXIubGlua25hbWUsXG4gICAgICBwYXg6IGhlYWRlci5wYXhcbiAgICB9KVxuXG4gICAgY29uc3QgbmV3SGVhZGVyID0ge1xuICAgICAgbmFtZTogJ1BheEhlYWRlcicsXG4gICAgICBtb2RlOiBoZWFkZXIubW9kZSxcbiAgICAgIHVpZDogaGVhZGVyLnVpZCxcbiAgICAgIGdpZDogaGVhZGVyLmdpZCxcbiAgICAgIHNpemU6IHBheEhlYWRlci5ieXRlTGVuZ3RoLFxuICAgICAgbXRpbWU6IGhlYWRlci5tdGltZSxcbiAgICAgIHR5cGU6ICdwYXgtaGVhZGVyJyxcbiAgICAgIGxpbmtuYW1lOiBoZWFkZXIubGlua25hbWUgJiYgJ1BheEhlYWRlcicsXG4gICAgICB1bmFtZTogaGVhZGVyLnVuYW1lLFxuICAgICAgZ25hbWU6IGhlYWRlci5nbmFtZSxcbiAgICAgIGRldm1ham9yOiBoZWFkZXIuZGV2bWFqb3IsXG4gICAgICBkZXZtaW5vcjogaGVhZGVyLmRldm1pbm9yXG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKGhlYWRlcnMuZW5jb2RlKG5ld0hlYWRlcikpXG4gICAgdGhpcy5wdXNoKHBheEhlYWRlcilcbiAgICBvdmVyZmxvdyh0aGlzLCBwYXhIZWFkZXIuYnl0ZUxlbmd0aClcblxuICAgIG5ld0hlYWRlci5zaXplID0gaGVhZGVyLnNpemVcbiAgICBuZXdIZWFkZXIudHlwZSA9IGhlYWRlci50eXBlXG4gICAgdGhpcy5wdXNoKGhlYWRlcnMuZW5jb2RlKG5ld0hlYWRlcikpXG4gIH1cblxuICBfZG9EcmFpbiAoKSB7XG4gICAgY29uc3QgZHJhaW4gPSB0aGlzLl9kcmFpblxuICAgIHRoaXMuX2RyYWluID0gbm9vcFxuICAgIGRyYWluKClcbiAgfVxuXG4gIF9wcmVkZXN0cm95ICgpIHtcbiAgICBjb25zdCBlcnIgPSBnZXRTdHJlYW1FcnJvcih0aGlzKVxuXG4gICAgaWYgKHRoaXMuX3N0cmVhbSkgdGhpcy5fc3RyZWFtLmRlc3Ryb3koZXJyKVxuXG4gICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9wZW5kaW5nLnNoaWZ0KClcbiAgICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgICAgIHN0cmVhbS5fY29udGludWVPcGVuKClcbiAgICB9XG5cbiAgICB0aGlzLl9kb0RyYWluKClcbiAgfVxuXG4gIF9yZWFkIChjYikge1xuICAgIHRoaXMuX2RvRHJhaW4oKVxuICAgIGNiKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhY2sgKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYWNrKG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1vZGVUb1R5cGUgKG1vZGUpIHtcbiAgc3dpdGNoIChtb2RlICYgY29uc3RhbnRzLlNfSUZNVCkge1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZCTEs6IHJldHVybiAnYmxvY2stZGV2aWNlJ1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZDSFI6IHJldHVybiAnY2hhcmFjdGVyLWRldmljZSdcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGRElSOiByZXR1cm4gJ2RpcmVjdG9yeSdcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGSUZPOiByZXR1cm4gJ2ZpZm8nXG4gICAgY2FzZSBjb25zdGFudHMuU19JRkxOSzogcmV0dXJuICdzeW1saW5rJ1xuICB9XG5cbiAgcmV0dXJuICdmaWxlJ1xufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIG92ZXJmbG93IChzZWxmLCBzaXplKSB7XG4gIHNpemUgJj0gNTExXG4gIGlmIChzaXplKSBzZWxmLnB1c2goRU5EX09GX1RBUi5zdWJhcnJheSgwLCA1MTIgLSBzaXplKSlcbn1cblxuZnVuY3Rpb24gbWFwV3JpdGFibGUgKGJ1Zikge1xuICByZXR1cm4gYjRhLmlzQnVmZmVyKGJ1ZikgPyBidWYgOiBiNGEuZnJvbShidWYpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/pack.js\n");

/***/ })

};
;